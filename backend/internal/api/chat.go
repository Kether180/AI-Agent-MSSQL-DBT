package api

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/datamigrate-ai/backend/internal/config"
	"github.com/gin-gonic/gin"
)

// ChatHandler handles AI chat requests
type ChatHandler struct {
	cfg           *config.Config
	aiServiceURL  string
	httpClient    *http.Client
}

// ChatMessage represents a chat message
type ChatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

// ChatRequest represents the chat request body
type ChatRequest struct {
	Message string        `json:"message"`
	History []ChatMessage `json:"history,omitempty"`
}

// ChatResponse represents the chat response
type ChatResponse struct {
	Response string   `json:"response"`
	Sources  []string `json:"sources,omitempty"`
}

// NewChatHandler creates a new chat handler
func NewChatHandler(cfg *config.Config) *ChatHandler {
	aiServiceURL := os.Getenv("AI_SERVICE_URL")
	if aiServiceURL == "" {
		aiServiceURL = "http://localhost:8081"
	}

	return &ChatHandler{
		cfg:          cfg,
		aiServiceURL: aiServiceURL,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// Chat handles chat messages by proxying to the AI service
// @Summary Send chat message
// @Description Send a message to the AI support assistant
// @Tags chat
// @Accept json
// @Produce json
// @Param request body ChatRequest true "Chat request"
// @Success 200 {object} ChatResponse
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Security BearerAuth
// @Router /chat [post]
func (h *ChatHandler) Chat(c *gin.Context) {
	var req ChatRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	if req.Message == "" {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Message is required"})
		return
	}

	// Try to proxy to AI service
	response, err := h.proxyToAIService(req)
	if err != nil {
		// Fallback to local knowledge base response
		response = h.getFallbackResponse(req.Message)
	}

	c.JSON(http.StatusOK, response)
}

// proxyToAIService forwards the request to the Python AI service
func (h *ChatHandler) proxyToAIService(req ChatRequest) (*ChatResponse, error) {
	// Marshal request
	jsonBody, err := json.Marshal(req)
	if err != nil {
		log.Printf("[Chat] Failed to marshal request: %v", err)
		return nil, err
	}

	// Create request to AI service
	aiURL := h.aiServiceURL + "/chat"
	log.Printf("[Chat] Proxying to AI service: %s", aiURL)
	aiReq, err := http.NewRequest("POST", aiURL, bytes.NewBuffer(jsonBody))
	if err != nil {
		log.Printf("[Chat] Failed to create request: %v", err)
		return nil, err
	}
	aiReq.Header.Set("Content-Type", "application/json")

	// Send request
	resp, err := h.httpClient.Do(aiReq)
	if err != nil {
		log.Printf("[Chat] Failed to call AI service: %v", err)
		return nil, err
	}
	defer resp.Body.Close()

	// Check response status
	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("AI service returned status %d: %s", resp.StatusCode, string(body))
	}

	// Parse response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	var chatResp ChatResponse
	if err := json.Unmarshal(body, &chatResp); err != nil {
		log.Printf("[Chat] Failed to parse AI response: %v", err)
		return nil, err
	}

	log.Printf("[Chat] AI service responded successfully")
	return &chatResp, nil
}

// getFallbackResponse returns a fallback response when AI service is unavailable
func (h *ChatHandler) getFallbackResponse(message string) *ChatResponse {
	// Simple keyword-based responses
	keywords := map[string]string{
		"migration": `DataMigrate AI helps you migrate MSSQL databases to dbt projects.
To create a migration:
1. Go to Migrations > New Migration
2. Configure your MSSQL connection
3. Select tables to migrate
4. Choose your target warehouse
5. Start the migration`,

		"connection": `Database connections in DataMigrate AI:
- SQL Server Authentication: Use username/password
- Windows Authentication: Use trusted connection
- Default port: 1433
Go to Settings > Connections to manage connections.`,

		"dbt": `dbt models generated by DataMigrate AI:
- Staging models: Raw data transformations
- Tests: Data quality checks
- Documentation: Auto-generated
Target warehouses: Snowflake, BigQuery, Fabric, Databricks, Redshift.`,

		"agent": `AI Agents available:
1. DataPrep Agent: Data profiling, deduplication
2. ML Fine-Tuning: Optimize transformations
3. Data Quality: Validate data integrity
4. Documentation: Generate docs
Access from Dashboard or /agents.`,

		"error": `Troubleshooting steps:
1. Verify database credentials
2. Check network/firewall settings
3. Ensure user has SELECT permissions
4. Check migration logs for details`,
	}

	// Check for keywords
	lowerMsg := message
	for keyword, response := range keywords {
		if contains(lowerMsg, keyword) {
			return &ChatResponse{Response: response}
		}
	}

	// Default response
	return &ChatResponse{
		Response: `I'm your DataMigrate AI Support Assistant. I can help with:
- Creating and managing migrations
- Database connection configuration
- Understanding dbt models
- Using AI agents
- Troubleshooting issues
What would you like to know more about?`,
	}
}

// contains checks if s contains substr (case-insensitive)
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(s) > 0 && containsHelper(s, substr))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if equalFold(s[i:i+len(substr)], substr) {
			return true
		}
	}
	return false
}

func equalFold(s, t string) bool {
	if len(s) != len(t) {
		return false
	}
	for i := 0; i < len(s); i++ {
		sr := s[i]
		tr := t[i]
		if sr >= 'A' && sr <= 'Z' {
			sr += 'a' - 'A'
		}
		if tr >= 'A' && tr <= 'Z' {
			tr += 'a' - 'A'
		}
		if sr != tr {
			return false
		}
	}
	return true
}
