"""
Migration endpoints for FastAPI
"""

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from pydantic import BaseModel, Field
from typing import Dict, List, Optional
from datetime import datetime

from app.database import SessionLocal
from app.models import Migration, ModelFile, APIKey
from app.services import MigrationService
from fastapi_app.dependencies import verify_api_key, get_db

router = APIRouter()


# Pydantic models for request/response
class MigrationCreate(BaseModel):
    """Request body for creating a migration"""
    metadata: Dict = Field(..., description="MSSQL metadata from extractor")
    project_name: str = Field(..., description="Name for the dbt project")
    project_path: Optional[str] = Field(None, description="Optional custom path for project")


class MigrationResponse(BaseModel):
    """Response model for migration details"""
    id: int
    user_id: int
    status: str
    phase: Optional[str]
    project_name: str
    total_models: int
    completed_models: int
    failed_models: int
    success_rate: float
    created_at: datetime
    started_at: Optional[datetime]
    completed_at: Optional[datetime]

    class Config:
        from_attributes = True


class ModelFileResponse(BaseModel):
    """Response model for generated model files"""
    id: int
    name: str
    model_type: str
    status: str
    file_path: Optional[str]
    validation_score: Optional[float]
    attempts: int

    class Config:
        from_attributes = True


# Background task to run migration
def run_migration_task(migration_id: int):
    """Background task to run migration"""
    db = SessionLocal()
    try:
        service = MigrationService(db)
        service.start_migration(migration_id)
    finally:
        db.close()


@router.post("/migrations", response_model=MigrationResponse, status_code=status.HTTP_201_CREATED)
async def create_migration(
    migration_data: MigrationCreate,
    background_tasks: BackgroundTasks,
    api_key: APIKey = Depends(verify_api_key),
    db = Depends(get_db)
):
    """
    Create a new migration.

    This endpoint creates a migration record and starts the migration process
    in the background using LangGraph agents.

    **Request Body:**
    - metadata: MSSQL metadata JSON from metadata extractor
    - project_name: Name for the dbt project
    - project_path: Optional custom path (defaults to ./migrations/<project_name>)

    **Response:**
    - Returns migration details with status 'pending' or 'running'
    - Migration runs in background and status can be checked via GET endpoint
    """
    try:
        service = MigrationService(db)

        # Create migration
        migration = service.create_migration(
            user_id=api_key.user_id,
            metadata=migration_data.metadata,
            project_name=migration_data.project_name,
            project_path=migration_data.project_path
        )

        # Store API key ID for tracking
        migration.api_key_id = api_key.id
        db.commit()
        db.refresh(migration)

        # Start migration in background
        background_tasks.add_task(run_migration_task, migration.id)

        return migration

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error creating migration: {str(e)}"
        )


@router.get("/migrations/{migration_id}", response_model=MigrationResponse)
async def get_migration(
    migration_id: int,
    api_key: APIKey = Depends(verify_api_key),
    db = Depends(get_db)
):
    """
    Get migration status and details.

    Returns current status of a migration including:
    - Overall status (pending, running, completed, failed)
    - Current phase (assessment, planning, execution, etc.)
    - Progress (completed/total models)
    - Success rate
    """
    migration = db.query(Migration).filter(Migration.id == migration_id).first()

    if not migration:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Migration not found"
        )

    # Check permissions (user can only access their own migrations)
    if migration.user_id != api_key.user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )

    return migration


@router.get("/migrations/{migration_id}/models", response_model=List[ModelFileResponse])
async def get_migration_models(
    migration_id: int,
    api_key: APIKey = Depends(verify_api_key),
    db = Depends(get_db)
):
    """
    Get all generated models for a migration.

    Returns list of all dbt models generated by the migration, including:
    - Model name and type (staging, intermediate, fact)
    - Status (pending, completed, failed)
    - Validation score (if available)
    - Number of attempts
    """
    migration = db.query(Migration).filter(Migration.id == migration_id).first()

    if not migration:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Migration not found"
        )

    # Check permissions
    if migration.user_id != api_key.user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Access denied"
        )

    service = MigrationService(db)
    models = service.get_migration_models(migration_id)

    return models


@router.get("/migrations", response_model=List[MigrationResponse])
async def list_migrations(
    skip: int = 0,
    limit: int = 100,
    status_filter: Optional[str] = None,
    api_key: APIKey = Depends(verify_api_key),
    db = Depends(get_db)
):
    """
    List all migrations for the authenticated user.

    **Query Parameters:**
    - skip: Number of records to skip (for pagination)
    - limit: Maximum number of records to return (default 100, max 100)
    - status_filter: Optional status filter (pending, running, completed, failed)

    **Returns:**
    - List of migrations ordered by creation date (newest first)
    """
    # Limit max records
    limit = min(limit, 100)

    # Build query
    query = db.query(Migration).filter(Migration.user_id == api_key.user_id)

    # Apply status filter if provided
    if status_filter:
        query = query.filter(Migration.status == status_filter)

    # Order and paginate
    migrations = query.order_by(Migration.created_at.desc()).offset(skip).limit(limit).all()

    return migrations
